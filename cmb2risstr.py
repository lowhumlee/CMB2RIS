# -*- coding: utf-8 -*-
"""CMB2RISstr.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_BLWfmuoljwDQANZ9GJrwb4gDMCVsN1I
"""

import re
import streamlit as st
import io
from typing import List, Dict, Optional


class RISConverter:
    """
    A class to convert bibliographic text entries to RIS (Research Information Systems) format.
    """

    def __init__(self):
        self.ris_records = []

    def filter_valid_lines(self, text: str) -> List[str]:
        """
        Filter lines that start with more than two Latin uppercase characters.

        Args:
            text (str): Multi-line input text

        Returns:
            List[str]: List of valid lines
        """
        lines = text.strip().split('\n')
        valid_lines = []

        for line in lines:
            line = line.strip()
            if not line:
                continue

            # Check if line starts with more than 2 Latin uppercase characters
            match = re.match(r'^([A-Z]{3,})', line)
            if match:
                valid_lines.append(line)

        return valid_lines

    def extract_title(self, line: str) -> Optional[str]:
        """
        Extract title from the bibliographic line.
        Handles dual titles and author separation.
        Single '/' separates title from authors.
        Double '//' separates authors from journal.

        Args:
            line (str): Bibliographic line

        Returns:
            Optional[str]: Extracted title
        """
        # First, find where the initial author citation ends (after "et al." or similar patterns)
        author_pattern = r'^[A-Z]+,\s+[A-Z]\.(?:\s+et\s+al\.)?'
        match = re.match(author_pattern, line)

        if not match:
            return None

        # Get text after initial author citation
        remaining_text = line[match.end():].strip()

        # Find the title - it's between the initial author and the last single '/'
        # The title ends before the last single '/' which starts the detailed author list

        # First, split by '//' to separate from journal information
        before_journal = remaining_text.split('//')[0]

        # Now find single '/' characters that separate title from detailed authors
        # We need to find the last single '/' that's not part of '//'
        single_slash_positions = []
        i = 0
        while i < len(before_journal):
            if before_journal[i] == '/':
                # Check if it's a single '/' (not part of '//')
                if i == 0 or before_journal[i-1] != '/':
                    if i == len(before_journal) - 1 or before_journal[i+1] != '/':
                        single_slash_positions.append(i)
            i += 1

        if single_slash_positions:
            # Title is everything before the last single '/'
            last_slash_pos = single_slash_positions[-1]
            title_part = before_journal[:last_slash_pos].strip()
        else:
            # If no single '/', the entire text before '//' is the title
            title_part = before_journal.strip()

        # Handle dual titles separated by "; "
        if '; ' in title_part:
            titles = title_part.split('; ')
            # Keep only the Latin (English) version - typically the second one
            if len(titles) > 1:
                # Check which one contains more Latin characters
                latin_title = None
                for title in titles:
                    if re.search(r'[a-zA-Z]', title):
                        latin_chars = len(re.findall(r'[a-zA-Z]', title))
                        cyrillic_chars = len(re.findall(r'[а-яё]', title, re.IGNORECASE))
                        if latin_chars > cyrillic_chars:
                            latin_title = title.strip()
                            break

                if latin_title:
                    title_part = latin_title
                else:
                    # Default to second title if can't determine
                    title_part = titles[-1].strip()

        return title_part if title_part else None


    def extract_authors(self, line: str) -> List[str]:
        """
        Extract author names from the bibliographic line.
        Authors are between the last single '/' and the double '//' (journal separator).

        Args:
            line (str): Bibliographic line

        Returns:
            List[str]: List of author names
        """
        authors = []

        # Find the author section - it's after the last single '/' and before '//'
        # First, split by '//' to get the part before journal
        before_journal = line.split('//')[0]

        # Find single '/' characters that separate title from detailed authors
        single_slash_positions = []
        i = 0
        while i < len(before_journal):
            if before_journal[i] == '/':
                # Check if it's a single '/' (not part of '//')
                if i == 0 or before_journal[i-1] != '/':
                    if i == len(before_journal) - 1 or before_journal[i+1] != '/':
                        single_slash_positions.append(i)
            i += 1

        if single_slash_positions:
            # Authors are after the last single '/'
            last_slash_pos = single_slash_positions[-1]
            author_part = before_journal[last_slash_pos + 1:].strip()
        else:
            # If no single '/', no detailed author section found
            return authors

        # Parse individual authors separated by commas
        author_names = [name.strip() for name in author_part.split(',')]

        # Clean up author names and format them properly
        for name in author_names:
            name = name.strip()
            if name and len(name) > 1:  # Avoid single characters
                # Remove trailing periods
                name = name.rstrip('.')
                authors.append(name)

        return authors

    def extract_journal(self, line: str) -> Optional[str]:
        """
        Extract journal name from between // and volume information.

        Args:
            line (str): Bibliographic line

        Returns:
            Optional[str]: Journal name
        """
        # Find text between // and the first comma after it (which usually precedes volume)
        journal_match = re.search(r'//\s*([^,]+)', line)
        if journal_match:
            return journal_match.group(1).strip()
        return None

    def extract_volume(self, line: str) -> Optional[str]:
        """
        Extract volume number.

        Args:
            line (str): Bibliographic line

        Returns:
            Optional[str]: Volume number
        """
        # Look for volume after journal name (typically a number after comma)
        volume_match = re.search(r'//[^,]+,\s*(\d+)', line)
        if volume_match:
            return volume_match.group(1)
        return None

    def extract_year(self, line: str) -> Optional[str]:
        """
        Extract publication year.

        Args:
            line (str): Bibliographic line

        Returns:
            Optional[str]: Publication year
        """
        # Look for 4-digit year
        year_match = re.search(r'\b(19|20)\d{2}\b', line)
        if year_match:
            return year_match.group(0)
        return None

    def extract_issue(self, line: str) -> Optional[str]:
        """
        Extract issue number (typically after N or No).

        Args:
            line (str): Bibliographic line

        Returns:
            Optional[str]: Issue number
        """
        # Look for N followed by number
        issue_match = re.search(r'N\s*(\d+)', line)
        if issue_match:
            return issue_match.group(1)
        return None

    def extract_issn(self, line: str) -> Optional[str]:
        """
        Extract ISSN number.

        Args:
            line (str): Bibliographic line

        Returns:
            Optional[str]: ISSN number
        """
        # Look for ISSN pattern
        issn_match = re.search(r'ISSN\s+([\d-]+)', line)
        if issn_match:
            return issn_match.group(1)
        return None

    def extract_pages(self, line: str) -> Optional[str]:
        """
        Extract page range (usually after с.).

        Args:
            line (str): Bibliographic line

        Returns:
            Optional[str]: Page range
        """
        # Look for pages after с. (Cyrillic 'c' for 'страница')
        pages_match = re.search(r'с\.\s*([\d-]+)', line)
        if pages_match:
            return pages_match.group(1)
        return None


    def parse_line_to_ris(self, line: str) -> Dict[str, any]:
        """
        Parse a single bibliographic line into RIS fields.

        Args:
            line (str): Bibliographic line

        Returns:
            Dict[str, any]: Dictionary containing RIS fields
        """
        ris_record = {
            'TY': 'JOUR',  # Always journal article
            'TI': self.extract_title(line),
            'AU': self.extract_authors(line),
            'JO': self.extract_journal(line),
            'VL': self.extract_volume(line),
            'PY': self.extract_year(line),
            'IS': self.extract_issue(line),
            'SN': self.extract_issn(line),
            'PG': self.extract_pages(line)
        }

        return ris_record

    def format_ris_record(self, record: Dict[str, any]) -> str:
        """
        Format a single RIS record as a string.

        Args:
            record (Dict[str, any]): RIS record dictionary

        Returns:
            str: Formatted RIS record
        """
        ris_lines = []

        # Type of reference (always first)
        ris_lines.append(f"TY  - {record['TY']}")

        # Title
        if record['TI']:
            ris_lines.append(f"TI  - {record['TI']}")

        # Authors (each on separate line)
        if record['AU']:
            for author in record['AU']:
                if author:
                    ris_lines.append(f"AU  - {author}")

        # Journal
        if record['JO']:
            ris_lines.append(f"JO  - {record['JO']}")

        # Volume
        if record['VL']:
            ris_lines.append(f"VL  - {record['VL']}")

        # Year
        if record['PY']:
            ris_lines.append(f"PY  - {record['PY']}")

        # Issue
        if record['IS']:
            ris_lines.append(f"IS  - {record['IS']}")

        # ISSN
        if record['SN']:
            ris_lines.append(f"SN  - {record['SN']}")

        # Pages - Use SP/EP if a range is found, otherwise just SP
        if record['PG']:
            pages = record['PG']
            if '-' in pages:
                try:
                    start_page, end_page = pages.split('-')
                    if start_page.strip():
                         ris_lines.append(f"SP  - {start_page.strip()}")
                    if end_page.strip():
                         ris_lines.append(f"EP  - {end_page.strip()}")
                except ValueError:
                    # If splitting fails, treat the whole string as a single start page
                    ris_lines.append(f"SP  - {pages.strip()}")
            else:
                # If no hyphen, treat the whole string as a single start page
                ris_lines.append(f"SP  - {pages.strip()}")
        # End of record
        ris_lines.append("ER  - ")
        return '\n'.join(ris_lines)

    def process_text_to_ris(self, input_text: str) -> str:
        """
        Main function to process input text and generate RIS format.

        Args:
            input_text (str): Multi-line bibliographic text

        Returns:
            str: Complete RIS formatted output
        """
        if not input_text.strip():
            return ""

        # Step 1: Filter valid lines
        valid_lines = self.filter_valid_lines(input_text)

        if not valid_lines:
            return "No valid bibliographic entries found. Please ensure entries start with 3+ uppercase letters."

        # Step 2: Parse each line and convert to RIS
        ris_output = []

        for line in valid_lines:
            record = self.parse_line_to_ris(line)
            formatted_record = self.format_ris_record(record)
            ris_output.append(formatted_record)

        return '\n\n'.join(ris_output)


# --- Streamlit App Layout and Logic ---

st.markdown("""
    <div style="text-align: center; margin-bottom: 20px;">
        <h2 style="color: #1f77b4;">📚 Bibliographic Text to RIS Converter</h2>
        <p style="color: #666;">Paste your bibliographic text below and convert it to RIS format</p>
    </div>
""", unsafe_allow_html=True)

st.markdown("""
    <div style="background-color: #f8f9fa; padding: 20px; border-radius: 10px; margin: 20px 0;">
        <h3 style="color: #495057; margin-top: 0;">📋 Instructions</h3>
        <ol style="color: #6c757d; line-height: 1.6;">
            <li><strong>Paste your bibliographic text</strong> into the text area below</li>
            <li>The text should contain entries starting with <strong>3+ uppercase letters</strong> (e.g., "ZAYKOVA, K. et al...")</li>
            <li>Click <strong>"Convert to RIS"</strong> to process the text</li>
            <li>Review the generated RIS output in the area below</li>
            <li>Click <strong>"Download RIS File"</strong> to save the result</li>
        </ol>

        <h4 style="color: #495057; margin-top: 20px;">✨ Features</h4>
        <ul style="color: #6c757d; line-height: 1.6;">
            <li>Automatically handles dual-language titles (keeps English version)</li>
            <li>Extracts authors, journal names, volumes, years, issues, ISSN, and page numbers</li>
            <li>Generates proper RIS format compatible with reference managers</li>
            <li>Real-time processing with error handling</li>
        </ul>
    </div>
""", unsafe_allow_html=True)

# Input text area
input_text = st.text_area(
    'Input Text:',
    '',
    height=200,
    placeholder='Paste your bibliographic text here...\n\nExample:\nZAYKOVA, K. et al. Antibiotic prescribing practices...'
)

# Buttons and Status
col1, col2, col3 = st.columns(3)

# Use session state to manage RIS output and status
if 'ris_output' not in st.session_state:
    st.session_state.ris_output = ""
if 'status_message' not in st.session_state:
     st.session_state.status_message = '<p style="color: #666; text-align: center;">Ready to convert bibliographic text to RIS format</p>'
if 'download_disabled' not in st.session_state:
    st.session_state.download_disabled = True

with col1:
    convert_button = st.button('🔄 Convert to RIS')

with col2:
    # Download button is enabled/disabled based on state
 if st.session_state.ris_output:
        download_button = st.download_button(
            label='📥 Download RIS File',
            data=st.session_state.ris_output.encode('utf-8'),
            file_name='bibliography.ris',
            mime='application/x-research-info-systems',
            disabled=False
        )
    else:
        download_button = st.download_button(
            label='📥 Download RIS File',
            data="".encode('utf-8'),
            file_name='bibliography.ris',
            mime='application/x-research-info-systems',
            disabled=True
        )

with col3:
    clear_button = st.button('🗑️ Clear All')

# Display status message
st.markdown(st.session_state.status_message, unsafe_allow_html=True)

# Output area (displaying the RIS output)
st.markdown("---") # Separator
st.write("Generated RIS Output:")
output_placeholder = st.empty() # Placeholder to display output

# --- Button Logic ---

converter = RISConverter()

if convert_button:
    if not input_text.strip():
        st.session_state.status_message = '<p style="color: #d9534f;">⚠️ Paste some text first</p>'
        st.session_state.download_disabled = True
    else:
        st.session_state.status_message = '<p style="color: #5bc0de;">🔄 Converting to RIS format...</p>'
        output_placeholder.text("Converting...") # Provide immediate feedback

        try:
            # Convert to RIS
            st.session_state.ris_output = converter.process_text_to_ris(input_text)

            if "No valid bibliographic entries found" in st.session_state.ris_output:
                 st.session_state.status_message = '<p style="color: #d9534f;">❌ No valid entries found. Please ensure entries start with 3+ uppercase letters.</p>'
                 st.session_state.download_disabled = True
                 output_placeholder.text(st.session_state.ris_output)
            else:
                # Count records
                record_count = st.session_state.ris_output.count('TY  - JOUR')

                # Update status and enable download
                st.session_state.status_message = f'<p style="color: #5cb85c;">✅ Successfully converted {record_count} record(s) to RIS format</p>'
                st.session_state.download_disabled = False
                output_placeholder.code(st.session_state.ris_output, language='ris') # Display output as code block

        except Exception as e:
            st.session_state.status_message = f'<p style="color: #d9534f;">❌ Error during conversion: {str(e)}</p>'
            st.session_state.download_disabled = True
            output_placeholder.text(f"Error: {e}")

    # Rerun to update the UI based on session state
    st.experimental_rerun()
    st.stop()
elif clear_button:
    st.session_state.ris_output = ""
    st.session_state.download_disabled = True
    st.session_state.status_message = '<p style="color: #666; text-align: center;">Ready to convert bibliographic text to RIS format</p>'
    input_text = "" # Clear the text area

    # Rerun to clear and update the UI
    st.experimental_rerun()
    st.stop()
else:
    # Initial display or if no button is pressed
    if st.session_state.ris_output:
        output_placeholder.code(st.session_state.ris_output, language='ris')
    else:
        output_placeholder.text("RIS output will appear here after conversion.")
